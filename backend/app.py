"""Backend application entry-point.

This module exposes :func:`create_app`, a small factory that builds and
configures the FastAPI instance used by both the local development server
(`uvicorn`) and the AWS Lambda handler. Keeping the setup in a function makes
it easy for tests to create isolated apps and mirrors the pattern recommended
by FastAPI.
"""

import asyncio
import logging

from fastapi import Depends, FastAPI, HTTPException, Request
from fastapi.exceptions import RequestValidationError
from fastapi.middleware.cors import CORSMiddleware
from fastapi.responses import JSONResponse
from fastapi.security import OAuth2PasswordRequestForm

from backend.auth import authenticate_user, create_access_token, get_current_user
from backend.common.data_loader import resolve_paths
from backend.common.portfolio_utils import (
    _load_snapshot,
    refresh_snapshot_async,
    refresh_snapshot_in_memory,
)
from backend.config import config
from backend.routes.agent import router as agent_router
from backend.routes.alert_settings import router as alert_settings_router
from backend.routes.alerts import router as alerts_router
from backend.routes.compliance import router as compliance_router
from backend.routes.config import router as config_router
from backend.routes.instrument import router as instrument_router
from backend.routes.metrics import router as metrics_router
from backend.routes.movers import router as movers_router
from backend.routes.performance import router as performance_router
from backend.routes.portfolio import router as portfolio_router
from backend.routes.query import router as query_router
from backend.routes.quotes import router as quotes_router
from backend.routes.scenario import router as scenario_router
from backend.routes.screener import router as screener_router
from backend.routes.support import router as support_router
from backend.routes.timeseries_admin import router as timeseries_admin_router
from backend.routes.timeseries_edit import router as timeseries_edit_router
from backend.routes.timeseries_meta import router as timeseries_router
from backend.routes.trading_agent import router as trading_agent_router
from backend.routes.transactions import router as transactions_router
from backend.routes.user_config import router as user_config_router
from backend.routes.virtual_portfolio import router as virtual_portfolio_router
from backend.utils import page_cache


def create_app() -> FastAPI:
    """Create and configure the FastAPI application.

    The function wires together middleware, registers routers and primes the
    in-memory price snapshot so the first request is quick. Returning the app
    instance instead of creating it at module import time keeps things
    test-friendly and avoids accidental state sharing between invocations.
    """

    # The FastAPI constructor accepts a few descriptive fields that end up in
    # the autogenerated OpenAPI/Swagger documentation.
    app = FastAPI(title="Allotmint API", version="1.0", docs_url="/docs")
    app.state.background_tasks = []

    paths = resolve_paths(config.repo_root, config.accounts_root)
    app.state.repo_root = paths.repo_root
    app.state.accounts_root = paths.accounts_root
    app.state.virtual_pf_root = paths.virtual_pf_root

    # ───────────────────────────── CORS ─────────────────────────────
    # The frontend origin varies by environment. Read the whitelist from
    # configuration and fall back to permissive settings during development.
    cors_origins = config.cors_origins or ["*"]
    app.add_middleware(
        CORSMiddleware,
        allow_origins=cors_origins,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # ──────────────────────────── Routers ────────────────────────────
    # The API surface is composed of a few routers grouped by concern.
    # Sensitive routes are guarded by a JWT-based dependency.
    if config.disable_auth:
        protected = []
    else:
        protected = [Depends(get_current_user)]
    app.include_router(portfolio_router, dependencies=protected)
    app.include_router(performance_router, dependencies=protected)
    app.include_router(instrument_router)
    app.include_router(timeseries_router)
    app.include_router(timeseries_edit_router)
    app.include_router(timeseries_admin_router, dependencies=protected)
    app.include_router(transactions_router, dependencies=protected)
    app.include_router(alert_settings_router)
    app.include_router(alerts_router)
    app.include_router(compliance_router)
    app.include_router(screener_router)
    app.include_router(support_router)
    app.include_router(query_router)
    app.include_router(virtual_portfolio_router, dependencies=protected)
    app.include_router(metrics_router)
    app.include_router(agent_router)
    app.include_router(trading_agent_router, dependencies=protected)
    app.include_router(config_router)
    app.include_router(quotes_router)
    app.include_router(movers_router)
    app.include_router(user_config_router, dependencies=protected)
    app.include_router(scenario_router)

    @app.exception_handler(RequestValidationError)
    async def validation_exception_handler(request: Request, exc: RequestValidationError):
        """Return a 400 status for validation errors.

        FastAPI's default is 422, but for query parameter issues a 400 response
        is more appropriate for clients relying on standard HTTP semantics.
        """
        return JSONResponse(status_code=400, content={"detail": exc.errors()})

    @app.post("/token")
    async def login(form_data: OAuth2PasswordRequestForm = Depends()):
        user = authenticate_user(form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        token = create_access_token(user)
        return {"access_token": token, "token_type": "bearer"}

    # ────────────────────── Health-check endpoint ─────────────────────
    @app.get("/health")
    async def health():
        """Return a small payload used by tests and uptime monitors."""

        return {"status": "ok", "env": config.app_env or "test"}

    # ─────────────── Warm the price snapshot on startup ───────────────
    skip_warm = bool(config.skip_snapshot_warm)

    if not skip_warm:

        @app.on_event("startup")
        async def _warm_snapshot() -> None:
            """Pre-fetch recent price data so the first request is fast."""

            snapshot, ts = _load_snapshot()
            refresh_snapshot_in_memory(snapshot, ts)
            task = refresh_snapshot_async(days=config.snapshot_warm_days or 30)
            if isinstance(task, (asyncio.Task, asyncio.Future)):
                app.state.background_tasks.append(task)

    @app.on_event("shutdown")
    async def _shutdown() -> None:
        # cancel any running background tasks
        tasks = list(app.state.background_tasks)
        for task in tasks:
            task.cancel()
        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)
        await page_cache.cancel_refresh_tasks()
        for handler in logging.getLogger().handlers:
            try:
                handler.flush()
            except Exception:
                pass
        logging.shutdown()

    return app


# optional local test:  python -m backend.app
if __name__ == "__main__":
    import uvicorn

    uvicorn.run(create_app(), host="0.0.0.0", port=config.uvicorn_port or 8000)
