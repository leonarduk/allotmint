"""Backend application entry-point.

This module exposes :func:`create_app`, a small factory that builds and
configures the FastAPI instance used by both the local development server
(`uvicorn`) and the AWS Lambda handler. Keeping the setup in a function makes
it easy for tests to create isolated apps and mirrors the pattern recommended
by FastAPI.
"""

import asyncio
import logging
import os
from typing import List

from fastapi import APIRouter, Depends, FastAPI, HTTPException, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import OAuth2PasswordRequestForm

from backend.routes.instrument import router as instrument_router
from backend.routes.portfolio import (
    router as portfolio_router,
    owners,
    groups,
    OwnerSummary,
    GroupSummary,
)
from backend.routes.timeseries_meta import router as timeseries_router
from backend.routes.timeseries_edit import router as timeseries_edit_router
from backend.routes.timeseries_admin import router as timeseries_admin_router

from backend.routes.transactions import router as transactions_router
from backend.routes.alerts import router as alerts_router
from backend.routes.compliance import router as compliance_router
from backend.routes.screener import router as screener_router
from backend.routes.support import router as support_router
from backend.routes.query import router as query_router
from backend.routes.virtual_portfolio import router as virtual_portfolio_router
from backend.routes.metrics import router as metrics_router
from backend.routes.agent import router as agent_router
from backend.routes.trading_agent import router as trading_agent_router
from backend.routes.config import router as config_router
from backend.routes.quotes import router as quotes_router
from backend.routes.movers import router as movers_router
from backend.routes.scenario import router as scenario_router
from backend.routes.rebalance import router as rebalance_router
from backend.routes.reports import router as reports_router
from backend.common.portfolio_utils import (
    _load_snapshot,
    refresh_snapshot_async,
    refresh_snapshot_in_memory,
)
from backend.config import config
from backend.logging_setup import setup_logging
from backend.common.data_loader import resolve_paths
from backend.utils import page_cache
from backend.auth import authenticate_user, create_access_token, get_current_user


def create_app() -> FastAPI:
    """Create and configure the FastAPI application.

    The function wires together middleware, registers routers and primes the
    in-memory price snapshot so the first request is quick. Returning the app
    instance instead of creating it at module import time keeps things
    test-friendly and avoids accidental state sharing between invocations.
    """

    setup_logging()

    # The FastAPI constructor accepts a few descriptive fields that end up in
    # the autogenerated OpenAPI/Swagger documentation.
    app = FastAPI(title="Allotmint API", version="1.0", docs_url="/docs")
    app.state.background_tasks = []

    paths = resolve_paths(config.repo_root, config.accounts_root)
    app.state.repo_root = paths.repo_root
    app.state.accounts_root = paths.accounts_root
    app.state.virtual_pf_root = paths.virtual_pf_root

    # ───────────────────────────── CORS ─────────────────────────────
    # The frontend origin varies by environment. Read the whitelist from
    # configuration and fall back to permissive settings during development.
    cors_origins = config.cors_origins or ["*"]
    app.add_middleware(
        CORSMiddleware,
        allow_origins=cors_origins,
        allow_methods=["*"],
        allow_headers=["*"],
    )

    # ──────────────────────────── Routers ────────────────────────────
    # The API surface is composed of a few routers grouped by concern.
    # Sensitive routes are guarded by a JWT-based dependency.
    protected = [Depends(get_current_user)]

    # Public portfolio endpoints that don't require authentication
    public_portfolio_router = APIRouter()
    public_portfolio_router.add_api_route(
        "/owners",
        owners,
        response_model=List[OwnerSummary],
        tags=["portfolio"],
        methods=["GET"],
    )
    public_portfolio_router.add_api_route(
        "/groups",
        groups,
        response_model=List[GroupSummary],
        tags=["portfolio"],
        methods=["GET"],
    )
    app.include_router(public_portfolio_router)

    # Remaining portfolio endpoints remain protected
    app.include_router(portfolio_router, dependencies=protected)
    app.include_router(instrument_router)
    app.include_router(timeseries_router)
    app.include_router(timeseries_edit_router)
    app.include_router(timeseries_admin_router)
    app.include_router(transactions_router, dependencies=protected)
    app.include_router(alerts_router)
    app.include_router(compliance_router)
    app.include_router(screener_router)
    app.include_router(support_router)
    app.include_router(query_router)
    app.include_router(virtual_portfolio_router, dependencies=protected)
    app.include_router(metrics_router)
    app.include_router(agent_router)
    app.include_router(trading_agent_router, dependencies=protected)
    app.include_router(config_router)
    app.include_router(quotes_router)
    app.include_router(movers_router)
    app.include_router(scenario_router)
    app.include_router(rebalance_router)
    app.include_router(reports_router, dependencies=protected)

    @app.post("/token")
    async def login(form_data: OAuth2PasswordRequestForm = Depends()):
        user = authenticate_user(form_data.username, form_data.password)
        if not user:
            raise HTTPException(status_code=400, detail="Incorrect username or password")
        token = create_access_token(user)
        return {"access_token": token, "token_type": "bearer"}

    # ────────────────────── Health-check endpoint ─────────────────────
    @app.get("/health")
    async def health():
        """Return a small payload used by tests and uptime monitors."""

        return {"status": "ok", "env": config.app_env or "test"}

    # ─────────────── Warm the price snapshot on startup ───────────────
    skip_warm = bool(config.skip_snapshot_warm)

    if not skip_warm:
        @app.on_event("startup")
        async def _warm_snapshot() -> None:
            """Pre-fetch recent price data so the first request is fast."""

            snapshot, ts = _load_snapshot()
            refresh_snapshot_in_memory(snapshot, ts)
            task = refresh_snapshot_async(days=config.snapshot_warm_days or 30)
            if isinstance(task, (asyncio.Task, asyncio.Future)):
                app.state.background_tasks.append(task)

    @app.on_event("shutdown")
    async def _shutdown() -> None:
        # cancel any running background tasks
        tasks = list(app.state.background_tasks)
        for task in tasks:
            task.cancel()
        if tasks:
            await asyncio.gather(*tasks, return_exceptions=True)
        await page_cache.cancel_refresh_tasks()
        for handler in logging.getLogger().handlers:
            try:
                handler.flush()
            except Exception:
                pass
        logging.shutdown()

    return app


# optional local test:  python -m backend.app
if __name__ == "__main__":
    import uvicorn

    uvicorn.run(
        create_app(), host="0.0.0.0", port=config.uvicorn_port or 8000
    )
